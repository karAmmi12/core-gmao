// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model Asset {
  id           String   @id
  name         String
  serialNumber String   @unique
  status       String
  createdAt    DateTime @default(now())

  // Hiérarchie des actifs (Site > Bâtiment > Ligne > Machine > Composant)
  parentId     String?
  parent       Asset?   @relation("AssetHierarchy", fields: [parentId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  children     Asset[]  @relation("AssetHierarchy")

  // Métadonnées supplémentaires
  assetType    String?  // SITE, BUILDING, LINE, MACHINE, COMPONENT
  location     String?  // Localisation physique
  manufacturer String?  // Fabricant
  modelNumber  String?  // Numéro de modèle

  // Relation : une machine a plusieurs interventions
  workOrders   WorkOrder[]
  maintenanceSchedules MaintenanceSchedule[]
  partRequests PartRequest[]

  @@index([parentId])
}

model Technician {
  id          String   @id
  name        String
  email       String   @unique
  phone       String?
  skills      String   // JSON array: ["Électricité", "Mécanique", "Hydraulique"]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Relations
  workOrders  WorkOrder[]
  maintenanceSchedules MaintenanceSchedule[]

  @@map("technicians")
}

model WorkOrder {
  id          String   @id
  title       String   // Ex: "Changer le filtre"
  description String?  // Description détaillée
  status      String   // DRAFT, PENDING, APPROVED, REJECTED, PLANNED, ASSIGNED, IN_PROGRESS, ON_HOLD, COMPLETED, CANCELLED
  priority    String   // LOW, HIGH
  type        String   @default("CORRECTIVE") // PREVENTIVE, CORRECTIVE
  createdAt   DateTime @default(now())

  // Planification
  scheduledAt       DateTime?  // Date/heure prévue
  startedAt         DateTime?  // Date/heure de début réel
  completedAt       DateTime?  // Date/heure de fin réelle
  estimatedDuration Int?       // Durée estimée en minutes
  actualDuration    Int?       // Durée réelle en minutes

  // Affectation technicien
  assignedToId String?
  assignedTo   Technician? @relation(fields: [assignedToId], references: [id], onDelete: SetNull)

  // Coûts
  laborCost     Float  @default(0)  // Coût main d'œuvre
  materialCost  Float  @default(0)  // Coût matériel
  totalCost     Float  @default(0)  // Coût total
  estimatedCost Float? // Coût estimé (déclenche approbation si élevé)

  // Approbation (workflow conditionnel)
  requiresApproval Boolean   @default(false) // Flag automatique selon type/priorité/coût
  approvedById     String?
  approvedBy       User?     @relation("WorkOrderApprovedBy", fields: [approvedById], references: [id])
  approvedAt       DateTime?
  rejectionReason  String?

  // Relation vers Asset
  assetId     String
  asset       Asset   @relation(fields: [assetId], references: [id])

  // Pièces utilisées
  parts       WorkOrderPart[]
  partRequests PartRequest[]

  @@index([assignedToId])
  @@index([scheduledAt])
  @@index([status])
  @@index([requiresApproval])
  @@map("work_orders")
}

model Part {
  id               String   @id
  reference        String   @unique  // Référence unique (ex: FLT-2024-001)
  name             String              // Nom de la pièce
  description      String?             // Description détaillée
  category         String?             // Catégorie (Filtres, Joints, Roulements, etc.)
  unitPrice        Float               // Prix unitaire en €
  quantityInStock  Int      @default(0) // Quantité en stock
  minStockLevel    Int      @default(5) // Seuil d'alerte stock bas
  supplier         String?             // Fournisseur principal
  supplierRef      String?             // Référence fournisseur
  location         String?             // Emplacement dans l'entrepôt
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  stockMovements   StockMovement[]
  workOrderParts   WorkOrderPart[]
  partRequests     PartRequest[]

  @@index([reference])
  @@index([category])
  @@map("parts")
}

model StockMovement {
  id          String   @id
  partId      String
  part        Part     @relation(fields: [partId], references: [id])
  
  type        String   // IN (entrée) ou OUT (sortie)
  quantity    Int      // Quantité (positif pour entrée, négatif pour sortie)
  reason      String?  // Raison: "Achat", "Utilisation intervention", "Correction inventaire", etc.
  reference   String?  // Référence externe (bon de commande, n° intervention, etc.)
  
  createdAt   DateTime @default(now())
  createdBy   String?  // ID utilisateur (pour traçabilité future)

  @@index([partId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

model WorkOrderPart {
  id           String     @id
  workOrderId  String
  workOrder    WorkOrder  @relation(fields: [workOrderId], references: [id], onDelete: Cascade)
  
  partId       String
  part         Part       @relation(fields: [partId], references: [id])
  
  // Quantités avec workflow
  quantityPlanned   Int        // Quantité prévue/demandée
  quantityReserved  Int        @default(0) // Quantité réservée en stock
  quantityConsumed  Int        @default(0) // Quantité réellement consommée
  
  // Statut du workflow
  status       String     @default("PLANNED") // PLANNED, RESERVED, PARTIALLY_RESERVED, CONSUMED, CANCELLED
  
  // Prix
  unitPrice    Float      // Prix unitaire au moment de la planification
  totalPrice   Float      // Prix total = quantityConsumed * unitPrice (calculé à la consommation)
  
  // Traçabilité
  requestedById String?   // Technicien qui a demandé (si demande terrain)
  requestedBy   User?     @relation("PartRequestedBy", fields: [requestedById], references: [id])
  approvedById  String?   // Manager qui a approuvé
  approvedBy    User?     @relation("PartApprovedBy", fields: [approvedById], references: [id])
  approvedAt    DateTime?
  consumedAt    DateTime? // Date de consommation réelle
  
  notes        String?    // Notes/commentaires
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([workOrderId])
  @@index([partId])
  @@index([status])
  @@map("work_order_parts")
}

// Demandes urgentes de pièces (hors OT ou avant création OT)
model PartRequest {
  id            String    @id
  
  // Pièce demandée
  partId        String
  part          Part      @relation(fields: [partId], references: [id])
  quantity      Int
  
  // Demandeur et contexte
  requestedById String
  requestedBy   User      @relation("PartRequestCreatedBy", fields: [requestedById], references: [id])
  reason        String    // Raison de la demande
  urgency       String    @default("NORMAL") // LOW, NORMAL, HIGH, CRITICAL
  
  // Lien optionnel avec un OT existant ou un équipement
  workOrderId   String?
  workOrder     WorkOrder? @relation(fields: [workOrderId], references: [id])
  assetId       String?
  asset         Asset?    @relation(fields: [assetId], references: [id])
  
  // Workflow de validation
  status        String    @default("PENDING") // PENDING, APPROVED, REJECTED, DELIVERED, CANCELLED
  
  approvedById  String?
  approvedBy    User?     @relation("PartRequestApprovedBy", fields: [approvedById], references: [id])
  approvedAt    DateTime?
  rejectionReason String?
  
  deliveredAt   DateTime?
  deliveredById String?
  deliveredBy   User?     @relation("PartRequestDeliveredBy", fields: [deliveredById], references: [id])
  
  notes         String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([partId])
  @@index([requestedById])
  @@index([status])
  @@index([urgency])
  @@map("part_requests")
}

model MaintenanceSchedule {
  id                String    @id
  assetId           String
  asset             Asset     @relation(fields: [assetId], references: [id], onDelete: Cascade)
  
  title             String    
  description       String?   
  
  // Type de maintenance et déclenchement
  maintenanceType   String    @default("PREVENTIVE") // PREVENTIVE, PREDICTIVE
  triggerType       String    @default("TIME_BASED") // TIME_BASED, THRESHOLD_BASED
  
  // Champs pour TIME_BASED (maintenance préventive classique)
  frequency         String    @default("MONTHLY") // DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY
  intervalValue     Int       @default(1)
  lastExecutedAt    DateTime? 
  nextDueDate       DateTime  @default(now())
  
  // Champs pour THRESHOLD_BASED (maintenance prédictive)
  thresholdMetric   String?   // Ex: "Heures de fonctionnement", "Kilométrage", "Cycles"
  thresholdValue    Float?    // Valeur de seuil à ne pas dépasser
  thresholdUnit     String?   // Ex: "h", "km", "cycles"
  currentValue      Float?    @default(0) // Valeur actuelle du compteur
  
  estimatedDuration Float?    
  assignedToId      String?   
  assignedTo        Technician? @relation(fields: [assignedToId], references: [id])
  
  isActive          Boolean   @default(true)
  priority          String    @default("LOW")
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([assetId])
  @@index([nextDueDate])
  @@index([isActive])
  @@index([triggerType])
  @@map("maintenance_schedules")
}

// Configuration dynamique pour rendre l'application adaptable à tout type d'entreprise
model ConfigurationCategory {
  id          String   @id
  code        String   @unique  // TECHNICIAN_SKILL, ASSET_TYPE, WORK_ORDER_TYPE, PRIORITY, etc.
  name        String              // Nom affiché
  description String?             // Description de la catégorie
  isSystem    Boolean  @default(false) // True si ne peut pas être supprimée
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)     // Ordre d'affichage
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  items       ConfigurationItem[]

  @@map("configuration_categories")
}

model ConfigurationItem {
  id          String   @id
  categoryId  String
  category    ConfigurationCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  code        String              // Code technique (ex: ELECTRICAL, MECHANICAL)
  label       String              // Libellé affiché (ex: "Électricité", "Mécanique")
  description String?             // Description détaillée
  color       String?             // Couleur pour l'UI (ex: "#3b82f6")
  icon        String?             // Nom d'icône (ex: "wrench", "bolt")
  
  isDefault   Boolean  @default(false) // Item par défaut dans sa catégorie
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)     // Ordre d'affichage
  
  // Métadonnées additionnelles (JSON flexible)
  metadata    String?             // JSON pour données spécifiques
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([categoryId, code])
  @@index([categoryId])
  @@index([isActive])
  @@map("configuration_items")
}

// =============================================================================
// AUTHENTIFICATION & UTILISATEURS
// =============================================================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String
  password      String?   // Hash bcrypt, null jusqu'à activation
  role          String    @default("OPERATOR") // ADMIN, MANAGER, TECHNICIAN, OPERATOR, VIEWER
  isActive      Boolean   @default(false)
  
  // Système d'invitation
  inviteToken       String?   @unique
  inviteExpiresAt   DateTime?
  mustChangePassword Boolean  @default(true)
  
  // Sécurité
  lastLoginAt   DateTime?
  failedLogins  Int       @default(0)
  lockedUntil   DateTime?
  
  // Audit
  createdAt     DateTime  @default(now())
  createdById   String?   // ID de l'admin qui a créé ce compte
  createdBy     User?     @relation("UserCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  usersCreated  User[]    @relation("UserCreatedBy")
  updatedAt     DateTime  @updatedAt

  // Relations avec les pièces
  partsRequested      WorkOrderPart[] @relation("PartRequestedBy")
  partsApproved       WorkOrderPart[] @relation("PartApprovedBy")
  partRequestsCreated PartRequest[]   @relation("PartRequestCreatedBy")
  partRequestsApproved PartRequest[]  @relation("PartRequestApprovedBy")
  partRequestsDelivered PartRequest[] @relation("PartRequestDeliveredBy")

  // Relations avec les interventions
  workOrdersApproved  WorkOrder[]     @relation("WorkOrderApprovedBy")

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@map("users")
}
